var shell = require('electron').shell;

var pinboardObjectToDelete;
const tm = texmath.use(katex);
var md = window.markdownit({
    html: true,
    linkify: true,
    typographer: true,
    highlight: function (str, lang) {
        if (lang && hljs.getLanguage(lang)) {
            try {
                return '<pre class="hljs"><code>' +
                    hljs.highlight(lang, str, true).value +
                    '</code></pre>';
            } catch (__) { }
        }

        return '<pre class="hljs cbOverwrite"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
    }
}).use(window.markdownitEmoji)
  .use(window.markdownitSup)
  .use(window.markdownitSub)
  .use(window.markdownitTaskLists, {enabled: true})
  .use(tm);
md.renderer.rules.emoji = function(token, idx) {
    return twemoji.parse(token[idx].content);
};

var pbSaveArray = '{"objects":[]}';

// Open links externally by default
// Without this, links generated by markdown-it will be opened inside the electron app, making corona unaccessible
$(document).on('click', 'a[href^="http"]', function(event) {
    event.preventDefault();
    shell.openExternal(this.href);
});

// Zoom
$(document).ready(function () {
    var $panzoom = $('#pinboard').panzoom();
    $panzoom.parent().on('mousewheel.focal', function (e) {
        e.preventDefault();
        var delta = e.delta || e.originalEvent.wheelDelta;
        var zoomOut = delta ? delta < 0 : e.originalEvent.deltaY > 0;
        $panzoom.panzoom('zoom', zoomOut, {
            animate: false,
            minScale: 0.1,
            maxScale: 1,
            focal: e,
            rangeStep: 1
        });
    });

    $(document).on("mouseenter", ".pinboardObject", function (e) {
        $("#pinboard").panzoom("disable");
    });

    $(document).on("mouseleave", ".pinboardObject", function (e) {
        $("#pinboard").panzoom("enable");
    });
});

// Tabstop handling in textboxes
$(document).on('keydown', ".pinboardObject-text", function (e) {
    var keyCode = e.keyCode || e.which;

    if (keyCode == 9) {
        e.preventDefault();
        var start = this.selectionStart;
        var end = this.selectionEnd;

        // set textarea value to: text before caret + tab + text after caret
        $(this).val($(this).val().substring(0, start)
            + "\t"
            + $(this).val().substring(end));

        // put caret at right position again
        this.selectionStart =
        this.selectionEnd = start + 1;
        // update the markdown
        var result = md.render($(this).val());
        $(this).parent().parent().find(".pinboardObject-markdown").html(result);
    }
});


// Drag & Drop
function allowDrop(ev) {
    ev.preventDefault();
}

function drag(ev) {
    ev.dataTransfer.setData("text", ev.target.id);
}

function drop(ev) {
    ev.preventDefault();
    var type = ev.dataTransfer.getData("text");
    switch (type) {
        case "toolboxObject-text":
            var data = {
                id: uuidv4()
            };
            var template = $("#pinboardObject-text-template").html();
            var html = Mustache.render(template, data);
            $("#pinboard").append(html);
            var addedObject = $( "p:contains(" +  data.id + ")").closest(".pinboardObject");

            // TODO
            panMatrix = $("#pinboard").panzoom("getMatrix");
            // => [1, 0, 0, 1, 0, 0]
            addedObject.css({
                left: $(".pinboard-container").scrollLeft() + ev.pageX  - (addedObject.width() / 2),
                top: $(".pinboard-container").scrollTop() + ev.pageY - addedObject.height()
            });
            localizeElement(addedObject,currentLang);
        
            var handle = $("<div class='resize-handle'></div>").appendTo(addedObject);
            TweenLite.set(handle, { top: "150px", left: "200px" });

            Draggable.create(addedObject, {
                bounds: pinboard,
                autoScroll: 2,
                edgeResistance: 1,
                type: "top,left"
            });

            Draggable.create(handle, {
                type:"top,left",
                bounds:{minX:200,minY:150,maxX:Number.MAX_VALUE,maxY:Number.MAX_VALUE},
                onPress: function(e) {
                    e.stopPropagation(); // cancel drag
                },
                onDrag: function(e) {
                    TweenLite.set(this.target.parentNode, { width: this.x, height: this.y });
                }
            });

            toggleEdit(addedObject);
            break;
        case "toolboxObject-image":
            var data = {
                id: uuidv4()
            }
            var template = $("#pinboardObject-image-template").html();
            var html = Mustache.render(template, data);
            $("#pinboard").append(html);
            var addedObject = $( "p:contains(" +  data.id + ")").closest(".pinboardObject");
            setImage(addedObject);
            addedObject.css({
                left: $(".pinboard-container").scrollLeft() + ev.pageX - (addedObject.width() / 2),
                top: $(".pinboard-container").scrollTop() + ev.pageY - addedObject.height()
            });
            localizeElement(addedObject,currentLang);
        
            var handle = $("<div class='resize-handle'></div>").appendTo(addedObject);
            TweenLite.set(handle, { top: "150px", left: "200px" });

            Draggable.create(addedObject, {
                bounds: pinboard,
                autoScroll: 2,
                edgeResistance: 1,
                type: "top,left"
            });

            Draggable.create(handle, {
                type:"top,left",
                bounds:{minX:200,minY:150,maxX:Number.MAX_VALUE,maxY:Number.MAX_VALUE},
                onPress: function(e) {
                    e.stopPropagation(); // cancel drag
                },
                onDrag: function(e) {
                    TweenLite.set(this.target.parentNode, { width: this.x, height: this.y });
                }
            });
            break;
        case "toolboxObject-map":
            if (maps.length == 16) {
                iziToast.error({
                    id: 'error',
                    title: '',
                    message: 'Maximum number of maps reached',
                    position: 'bottomRight',
                    transitionIn: 'fadeInDown'
                });
                return;
            }
            var data = {
                id: uuidv4()
            }
            var template = $("#pinboardObject-map-template").html();
            var html = Mustache.render(template, data);
            $("#pinboard").append(html);
            var addedObject = $( "p:contains(" +  data.id + ")").closest(".pinboardObject");
            addedObject.css({
                left: $(".pinboard-container").scrollLeft() + ev.pageX - (addedObject.width() / 2),
                top: $(".pinboard-container").scrollTop() + ev.pageY - addedObject.height()
            });

            addMap(addedObject);

            localizeElement(addedObject,currentLang);
        
            var handle = $("<div class='resize-handle'></div>").appendTo(addedObject);
            TweenLite.set(handle, { top: "150px", left: "201px" });

            var dragInstance = Draggable.create(addedObject, {
                bounds: pinboard,
                autoScroll: 2,
                edgeResistance: 1,
                type: "top,left"
            });
            dragInstance[0].addEventListener("dragstart", disableMapDrag);
            dragInstance[0].addEventListener("dragend", enableMapDrag);

            Draggable.create(handle, {
                type:"top,left",
                bounds:{minX:201,minY:150,maxX:Number.MAX_VALUE,maxY:Number.MAX_VALUE},
                onPress: function(e) {
                    e.stopPropagation(); // cancel drag
                },
                onDrag: function(e) {
                    TweenLite.set(this.target.parentNode, { width: this.x, height: this.y });
                    resizeMap();
                }
            });
            break;
        case "toolboxObject-fl":
            var data = {
                id: uuidv4()
            }
            var template = $("#pinboardObject-fl-template").html();
            var html = Mustache.render(template, data);
            $("#pinboard").append(html);
            var addedObject = $( "p:contains(" +  data.id + ")").closest(".pinboardObject");
            setFile(addedObject);
            addedObject.css({
                left: $(".pinboard-container").scrollLeft() + ev.pageX - (addedObject.width() / 2),
                top: $(".pinboard-container").scrollTop() + ev.pageY - addedObject.height()
            });
            localizeElement(addedObject,currentLang);
        
            var handle = $("<div class='resize-handle'></div>").appendTo(addedObject);
            TweenLite.set(handle, { top: "150px", left: "261px" });

            Draggable.create(addedObject, {
                bounds: pinboard,
                autoScroll: 2,
                edgeResistance: 1,
                type: "top,left"
            });

            Draggable.create(handle, {
                type:"top,left",
                bounds:{minX:261,minY:150,maxX:Number.MAX_VALUE,maxY:Number.MAX_VALUE},
                onPress: function(e) {
                    e.stopPropagation(); // cancel drag
                },
                onDrag: function(e) {
                    TweenLite.set(this.target.parentNode, { width: this.x, height: this.y });
                    var tableObj = $(this.target).closest(".pbFl").find(".flTable-name");
                    var obj = $(this.target).closest(".pbFl").find(".pinboardObject-fl-name");
                    var tableWidth = tableObj.width();
                    TweenLite.set(obj, { width: this.x - 162}); //Why -162? I don't know. But with this value, the scaling works fine, so f*ck it
                }
            });
            break;
        case "toolboxObject-fol":
            var data = {
                id: uuidv4()
            }
            var template = $("#pinboardObject-fol-template").html();
            var html = Mustache.render(template, data);
            $("#pinboard").append(html);
            var addedObject = $( "p:contains(" +  data.id + ")").closest(".pinboardObject");
            setFolder(addedObject);
            addedObject.css({
                left: $(".pinboard-container").scrollLeft() + ev.pageX - (addedObject.width() / 2),
                top: $(".pinboard-container").scrollTop() + ev.pageY - addedObject.height()
            });
            localizeElement(addedObject,currentLang);
        
            var handle = $("<div class='resize-handle'></div>").appendTo(addedObject);
            TweenLite.set(handle, { top: "150px", left: "261px" });

            Draggable.create(addedObject, {
                bounds: pinboard,
                autoScroll: 2,
                edgeResistance: 1,
                type: "top,left"
            });

            Draggable.create(handle, {
                type:"top,left",
                bounds:{minX:261,minY:150,maxX:Number.MAX_VALUE,maxY:Number.MAX_VALUE},
                onPress: function(e) {
                    e.stopPropagation(); // cancel drag
                },
                onDrag: function(e) {
                    TweenLite.set(this.target.parentNode, { width: this.x, height: this.y });
                    var tableObj = $(this.target).closest(".pbFl").find(".flTable-name");
                    var obj = $(this.target).closest(".pbFl").find(".pinboardObject-fl-name");
                    var tableWidth = tableObj.width();
                    TweenLite.set(obj, { width: this.x - 162}); //Why -162? I don't know. But with this value, the scaling works fine, so f*ck it
                }
            });
            break;
    }
}

// Set the image of an image object
function setImage(addedObject) {
    dialog.showOpenDialog({filters: [{name: 'Images', extensions: ['jpg', 'png']}]}, function (FileName) {
        if (FileName !== undefined) {
            addedObject.find(".pinboardObject-image").css("background-image",'url("' + fileUrl(FileName[0]) + '")');
        }
    });
}
// Set the file of a FileLink
function setFile(addedObject) {
    dialog.showOpenDialog({filters: [{name: 'All Files', extensions: ['*']}],buttonLabel: "Select"}, function (FileName) {
        if (FileName !== undefined) {
            addedObject.find("#filepath").text(FileName[0]);
            addedObject.find(".pinboardObject-fl-name").text(path.basename(FileName[0]));
            var ext = path.extname(FileName[0]);
            setFileDetails(FileName[0], addedObject);
            setFLImage(ext, addedObject);
        } else {
            addedObject.remove();
        }
    });
}

// Set the folder of a FolderLink
function setFolder(addedObject) {
    dialog.showOpenDialog({filters: [{name: 'Folders', extensions: ['*']}],buttonLabel: "Select", properties: ["openDirectory"]}, function (FileName) {
        if (FileName !== undefined) {
            addedObject.find("#filepath").text(FileName[0]);
            addedObject.find(".pinboardObject-fl-name").text(path.basename(FileName[0]));
            setFileDetails(FileName[0], addedObject);
            setFLImage("folder", addedObject);
        } else {
            addedObject.remove();
        }
    });
}

var totalSize;
// Set the detail description of the file metadata
function setFileDetails(filepath, obj) {
    var fp = filepath;
    var typeC = obj.find(".flDetailTable-type-right");
    var pathC = obj.find(".flDetailTable-path-right");
    var sizeC = obj.find(".flDetailTable-size-right");

    stats = fs.statSync(fp);

    if (stats.isDirectory()) {
        typeC.text("Directory");
        totalSize = 0;
        var fileList = walkSync(fp);

        sizeC.text(autoFormatFilesize(totalSize));
    }
    if (stats.isFile()) {
        typeC.text(path.extname(fp));
        sizeC.text(autoFormatFilesize(stats.size))
    }
    pathC.text(fp);
}
// List all files in a directory in Node.js recursively in a synchronous fashion
function walkSync(dir,filelist) {
    files = fs.readdirSync(dir);
    filelist = filelist || [];
    files.forEach(function (file) {
        if (fs.statSync(path.join(dir, file)).isDirectory()) {
            filelist = walkSync(path.join(dir, file), filelist);
        }
        else {
            filelist.push(path.join(dir, file));
        }
        var stats = fs.statSync(path.join(dir, file));
        totalSize = totalSize + stats.size;
    });
    return filelist;
};

function autoFormatFilesize(fileSize) {
    if (fileSize > 1000000000) {
        return (fileSize / 1000000000.0)
            .toPrecision(3) + " GB";
    } else if (fileSize > 1000000) {
        return (fileSize / 1000000.0)
            .toPrecision(3) + " MB";
    } else if (fileSize > 1000) {
        return (fileSize / 1000.0)
            .toPrecision(3) + " KB";
    } else {
        return fileSize + " B"
    }
}

// Set the thumbnail of the file
// This is an absolute catastrophe and, just like localization, will have to be transferred to an external file
function setFLImage(ext, obj) {
    var imgCt = obj.find(".pinboardObject-fl-icon")
    switch (ext) {
        case ".jpg":
        case ".png":
        case ".bmp":
        case ".gif":
        case ".svg":
        case ".psd":
            imgCt.css("background-image", 'url("' + fileUrl("img/fileicons/image.svg") + '")');
            break;
        case ".txt":
            imgCt.css("background-image", 'url("' + fileUrl("img/fileicons/text.svg") + '")');
            break;
        case ".doc":
        case ".docx":
        case ".rtf":
            imgCt.css("background-image", 'url("' + fileUrl("img/fileicons/word.svg") + '")');
            break;
        case ".mp3":
        case ".ogg":
        case ".wav":
        case ".pcm":
        case ".aiff":
        case ".aac":
        case ".wma":
        case ".flac":
            imgCt.css("background-image", 'url("' + fileUrl("img/fileicons/audio.svg") + '")');
            break;
        case ".exe":
        case ".dll":
        case ".bat":
            imgCt.css("background-image", 'url("' + fileUrl("img/fileicons/exe.svg") + '")');
            break;
        case ".zip":
        case ".7z":
        case ".rar":
        case ".gz":
            imgCt.css("background-image", 'url("' + fileUrl("img/fileicons/archive.svg") + '")');
            break;
        case ".php":
        case ".py":
        case ".js":
        case ".html":
        case ".css":
            imgCt.css("background-image", 'url("' + fileUrl("img/fileicons/code.svg") + '")');
            break;
        case "folder":
            imgCt.css("background-image", 'url("' + fileUrl("img/fileicons/folder.svg") + '")');
            break;
    }
}

// Fixes File paths output by a Node.js function for the usage in CSS url("") parameters
function fileUrl(str) {
    if (typeof str !== 'string') {
        throw new Error('Expected a string');
    }

    var pathName = path.resolve(str).replace(/\\/g, '/');

    // Windows drive letter must be prefixed with a slash
    if (pathName[0] !== '/') {
        pathName = '/' + pathName;
    }

    return encodeURI('file://' + pathName);
};

// UI events

$(document).on('click', "#pinboardSave", function(ev) {
    savePinboard();
});

$(document).on('click', "#pinboardCancel", function(ev) {
    // Hide pinboard, delete content
    var pb = $("#pinboard");
    $(".pinboard-grid").css("display","none");
    pb.html("");
});

var imageBackgroundTypes = ['cover','contain','100% 100%'];
var imagebackgroundState = 0;
$(document).on('click', ".pinboardObject-image", function(ev){
    if (ev.ctrlKey) {
        var state = $(this).css('background-size')
        switch (state) {
            case 'cover':
            $(this).css('background-size','contain')
                break;
            case 'contain':
            $(this).css('background-size','100% 100%')
                break;
            case '100% 100%':
            $(this).css('background-size','cover')
                break;
        }   
    }
});

$(document).on('click', "#fileLinkOpen", function(ev) {
    var filepath = $(this).parent().parent().parent().parent().parent().parent().find("#filepath").text();
    filepath = path.normalize(filepath);
    shell.showItemInFolder(filepath);
});

$(document).on('click', "#deletePinboardObject", function(ev){
    pinboardObjectToDelete = $(this).parent().parent().parent();
    deleteMode = "pinboardObject";								// Der deleteMode gibt der Dialogsbestätigungsfunktion an, welcher Löschvorgang ausgeführt werden soll
	$(".alertOverlay").css("display","block");				    // Das Bestätigungsoverlay und der darin liegende Ja-Nein-Dialog werden sichtbar gemacht
});

$(document).on('click', "#editPinboardObject", function(ev){
    var object = $(this).parent().parent().parent();
    var type = object.attr("pbType");
    switch (type) {
        case "text":
            toggleEdit(object);
            break;
        case "image":
            setImage(object);
            break;
   }
});

// Prevents Draggable conflicting with map pan
$(document).on({
    mouseenter: function () {
        if (mapDraggable) {
            Draggable.get($(this).parent().parent()).disable();
        }
    },
    mouseleave: function () {
        Draggable.get($(this).parent().parent()).enable();
    }
}, ".pinboardObject-map");

// Edit mode switching
function toggleEdit(obj) {
    if ($(obj).find("#editPinboardObject").attr("loc") == "?savePinboardObject") {
        closeThis(obj);
        return;
    }
    var fin = $(obj).find("#mdFinished");
    var txt = $(obj).find(".pinboardObject-text");
    $(obj).find("#editPinboardObject").attr("loc", '?savePinboardObject');

    $(obj).find(".pinboardObject-mdPreview").css("display", "block");
    fin.css("display", "none");
    txt.css("display", "block");
    txt.focus();

    closeOthers(obj);

    localizeElement(obj, currentLang);
}

function closeOthers(currObj) {
    var allObj = $(".pinboardObject");
    var currId = currObj.find("#uuidpbobj").text();
    $.each(allObj, function(index, element) {
        var elemId = $(element).find("#uuidpbobj").text();
        if (elemId !== currId) {
            var fin = $(element).find("#mdFinished");
            var txt = $(element).find(".pinboardObject-text");

            $(element).find("#editPinboardObject").attr("loc",'?editPinboardObject');

            $(element).find(".pinboardObject-mdPreview").css("display","none");
            var result = $(element).find(".pinboardObject-markdown").html();
            var mdHe = $(element).find(".pinboardObject-mdPreview").height();
            fin.html(result);
            fin.parent().parent().css("height",mdHe - 26 + "px");    
            TweenLite.set($(element).find(".resize-handle"), { top: mdHe -26 + "px"});
            fin.css("display","block");
            txt.css("display", "none");

            localizeElement(element,currentLang);
        }
    });
}

function closeThis(obj) {
    var fin = $(obj).find("#mdFinished");
    var txt = $(obj).find(".pinboardObject-text");

    $(obj).find("#editPinboardObject").attr("loc",'?editPinboardObject');

    $(obj).find(".pinboardObject-mdPreview").css("display","none");
    var result = $(obj).find(".pinboardObject-markdown").html();
    var mdHe = $(obj).find(".pinboardObject-mdPreview").height();
    fin.html(result);
    fin.parent().parent().css("height",mdHe - 26 + "px");    
    TweenLite.set($(obj).find(".resize-handle"), { top: mdHe - 26 + "px"});
    fin.css("display","block");
    txt.css("display", "none");

    localizeElement(obj,currentLang);
}

// Markdown processing
$(document).on("input", ".pinboardObject-text", function() {
    var result = md.render($(this).val());
    $(this).parent().parent().find(".pinboardObject-markdown").html(result);
});

/*  
##################################
##       Saving & Loading    	##
##      of pinboardObjects      ##
##################################
*/

function savePinboard() {
    // Preparation of JSON save
    var pbJsonObj = JSON.parse(pbSaveArray);

    var pbObjs = $(".pinboardObject");
    $.each(pbObjs, function(index, element) {				    // Alle gespeicherten Kategorien werden durchlaufen
        var objType = $(element).attr("pbType");
        switch (objType) {
            case "text":
                var pbObj = {
                    id: $(element).find("#uuidpbobj").text(),
                    pbId: $("#pinboard").attr("pbID"),
                    type: objType,
                    top: $(element).css("top"),
                    left: $(element).css("left"),
                    width: $(element).css("width"),
                    height: $(element).css("height"),
                    text: $(element).find(".pinboardObject-text").val()
                }

                // Falls noch kein Objekt vorhanden ist, wird eine neue gepusht
                if ( jQuery.isEmptyObject(pbJsonObj['objects']) ) {
                    pbJsonObj['objects'].push(pbObj);
                }
                // In der Theorie können hier mehrere Kategorien aktualisiert werden, da die uuids einzigartig sind, sollte Mehrfachspeicherung in der Praxis nicht vorkommen
                var counter = 0;								// counter dient der Überprüfung, ob die Kategorie bereits existiert
                $.each(pbJsonObj['objects'], function(index, element) {     // Alle gespeicherten Objekte werden durchlaufen
                    if (element.id == pbObj.id) {							// ID-Match
                        counter++;										
                        element.top = pbObj.top;
                        element.left = pbObj.left;
                        element.width = pbObj.width;
                        element.height = pbObj.height;
                        element.text = pbObj.text;
                    }
                });
                // Wenn der Counter nach einem kompletten Durchlauf der Datei immer noch 0 ist, ist das zu speichernde Objekt noch nicht vorhanden
                // Statt einer Aktualisierung wird daher auch hier eine neues objekt gepusht, wie im Fall eines leeren Arrays
                if (counter == 0) {
                    pbJsonObj['objects'].push(pbObj);
                }

                break;
        
            case "image":
                var pbObj = {
                    id: $(element).find("#uuidpbobj").text(),
                    pbId: $("#pinboard").attr("pbID"),
                    type: objType,
                    top: $(element).css("top"),
                    left: $(element).css("left"),
                    width: $(element).css("width"),
                    height: $(element).css("height"),
                    imgPath: $(element).find(".pinboardObject-image").css("background-image"),
                    imgMode: $(element).find(".pinboardObject-image").css("background-size")
                }

                // Falls noch kein Objekt vorhanden ist, wird eine neue gepusht
                if ( jQuery.isEmptyObject(pbJsonObj['objects']) ) {
                    pbJsonObj['objects'].push(pbObj);
                }
                // In der Theorie können hier mehrere Kategorien aktualisiert werden, da die uuids einzigartig sind, sollte Mehrfachspeicherung in der Praxis nicht vorkommen
                var counter = 0;								// counter dient der Überprüfung, ob die Kategorie bereits existiert
                $.each(pbJsonObj['objects'], function(index, element) {     // Alle gespeicherten Objekte werden durchlaufen
                    if (element.id == pbObj.id) {							// ID-Match
                        counter++;										
                        element.top = pbObj.top;
                        element.left = pbObj.left;
                        element.width = pbObj.width;
                        element.height = pbObj.height;
                        element.imgPath = pbObj.imgPath;
                        element.imgMode = pbObj.imgMode;
                    }
                });
                // Wenn der Counter nach einem kompletten Durchlauf der Datei immer noch 0 ist, ist das zu speichernde Objekt noch nicht vorhanden
                // Statt einer Aktualisierung wird daher auch hier eine neues objekt gepusht, wie im Fall eines leeren Arrays
                if (counter == 0) {
                    pbJsonObj['objects'].push(pbObj);
                }

                break;

            case "map":
                var mapObject = maps[$(element).attr("mapID")];

                var pbObj = {
                    id: $(element).find("#uuidpbobj").text(),
                    pbId: $("#pinboard").attr("pbID"),
                    type: objType,
                    top: $(element).css("top"),
                    left: $(element).css("left"),
                    width: $(element).css("width"),
                    height: $(element).css("height"),
                    center: mapObject.getCenter(),
                    marker: mapObject.getSource("marker")._data.features[0].geometry.coordinates,
                    zoom: mapObject.getZoom(),
                    bearing: mapObject.getBearing(),
                    pitch: mapObject.getPitch()
                }

                // Falls noch kein Objekt vorhanden ist, wird eine neue gepusht
                if ( jQuery.isEmptyObject(pbJsonObj['objects']) ) {
                    pbJsonObj['objects'].push(pbObj);
                }
                // In der Theorie können hier mehrere Kategorien aktualisiert werden, da die uuids einzigartig sind, sollte Mehrfachspeicherung in der Praxis nicht vorkommen
                var counter = 0;								// counter dient der Überprüfung, ob die Kategorie bereits existiert
                $.each(pbJsonObj['objects'], function(index, element) {     // Alle gespeicherten Objekte werden durchlaufen
                    if (element.id == pbObj.id) {							// ID-Match
                        counter++;										
                        element.top = pbObj.top;
                        element.left = pbObj.left;
                        element.width = pbObj.width;
                        element.height = pbObj.height;
                        element.center = pbObj.center;
                        element.marker = pbObj.marker;
                        element.zoom = pbObj.zoom;
                        element.bearing = pbObj.bearing;
                        element.pitch = pbObj.pitch;
                    }
                });
                // Wenn der Counter nach einem kompletten Durchlauf der Datei immer noch 0 ist, ist das zu speichernde Objekt noch nicht vorhanden
                // Statt einer Aktualisierung wird daher auch hier eine neues objekt gepusht, wie im Fall eines leeren Arrays
                if (counter == 0) {
                    pbJsonObj['objects'].push(pbObj);
                }

                break;

            case "fl":
            case "fol":
                var pbObj = {
                    id: $(element).find("#uuidpbobj").text(),
                    pbId: $("#pinboard").attr("pbID"),
                    type: objType,
                    top: $(element).css("top"),
                    left: $(element).css("left"),
                    width: $(element).css("width"),
                    height: $(element).css("height"),
                    path: $(element).find("#filepath").text()
                }

                // Falls noch kein Objekt vorhanden ist, wird eine neue gepusht
                if ( jQuery.isEmptyObject(pbJsonObj['objects']) ) {
                    pbJsonObj['objects'].push(pbObj);
                }
                // In der Theorie können hier mehrere Kategorien aktualisiert werden, da die uuids einzigartig sind, sollte Mehrfachspeicherung in der Praxis nicht vorkommen
                var counter = 0;								// counter dient der Überprüfung, ob die Kategorie bereits existiert
                $.each(pbJsonObj['objects'], function(index, element) {     // Alle gespeicherten Objekte werden durchlaufen
                    if (element.id == pbObj.id) {							// ID-Match
                        counter++;										
                        element.top = pbObj.top;
                        element.left = pbObj.left;
                        element.width = pbObj.width;
                        element.height = pbObj.height;
                        element.path = pbObj.path;
                    }
                });
                // Wenn der Counter nach einem kompletten Durchlauf der Datei immer noch 0 ist, ist das zu speichernde Objekt noch nicht vorhanden
                // Statt einer Aktualisierung wird daher auch hier eine neues objekt gepusht, wie im Fall eines leeren Arrays
                if (counter == 0) {
                    pbJsonObj['objects'].push(pbObj);
                }

                break;
        }
    });

    pbSaveArray = JSON.stringify(pbJsonObj,null,4);					// Das JSON-Objekt wird wieder in Text umgewandelt und automatisch prettified
    log(pbSaveArray,"d");
    saveToFile("pb", pbSaveArray); 	
}

function loadConstructorPB(transferID) {
    var startTime = Date.now();
    var pb = $("#pinboard");

    var pbString = loadFromFile("pb");
    pbSaveArray = pbString;
    var pbObj = JSON.parse(pbSaveArray);

    $.each(pbObj['objects'], function (index, element) {
        if (element.pbId == transferID) {
            var data = {
                id: element.id
            }
            switch (element.type) {
                case "text":
                    var template = $("#pinboardObject-text-template").html();
                    var html = Mustache.render(template, data);
                    $("#pinboard").append(html);
                    var obj = pb.find("p:contains(" + element.id + ")").closest(".pinboardObject");

                    obj.css({
                        "top": element.top,
                        "left": element.left,
                        "width": element.width,
                        "height": element.height
                    });
                    var textbox = obj.find(".pinboardObject-text");
                    textbox.val(element.text);
                    var result = md.render(textbox.val());
                    textbox.parent().parent().find(".pinboardObject-markdown").html(result);

                    localizeElement(obj,currentLang);
        
                    var handle = $("<div class='resize-handle'></div>").appendTo(obj);
                    TweenLite.set(handle, { top: element.height, left: element.width });

                    Draggable.create(obj, {
                        bounds: pinboard,
                        autoScroll: 2,
                        edgeResistance: 1,
                        type: "top,left"
                    });

                    Draggable.create(handle, {
                        type:"top,left",
                        bounds:{minX:200,minY:150,maxX:Number.MAX_VALUE,maxY:Number.MAX_VALUE},
                        onPress: function(e) {
                            e.stopPropagation(); // cancel drag
                        },
                        onDrag: function(e) {
                            TweenLite.set(this.target.parentNode, { width: this.x, height: this.y });
                        }
                    });
                    break;
                case "image":
                    var template = $("#pinboardObject-image-template").html();
                    var html = Mustache.render(template, data);
                    $("#pinboard").append(html);
                    var obj = pb.find("p:contains(" + element.id + ")").closest(".pinboardObject");

                    obj.css({
                        "top": element.top,
                        "left": element.left,
                        "width": element.width,
                        "height": element.height
                    });
                    obj.find(".pinboardObject-image").css({
                        "background-image": element.imgPath,
                        "background-size": element.imgMode
                    });
                    localizeElement(obj,currentLang);
        
                    var handle = $("<div class='resize-handle'></div>").appendTo(obj);
                    TweenLite.set(handle, { top: element.height, left: element.width });

                    Draggable.create(obj, {
                        bounds: pinboard,
                        autoScroll: 2,
                        edgeResistance: 1,
                        type: "top,left"
                    });

                    Draggable.create(handle, {
                        type:"top,left",
                        bounds:{minX:200,minY:150,maxX:Number.MAX_VALUE,maxY:Number.MAX_VALUE},
                        onPress: function(e) {
                            e.stopPropagation(); // cancel drag
                        },
                        onDrag: function(e) {
                            TweenLite.set(this.target.parentNode, { width: this.x, height: this.y });
                        }
                    });
                    break;
                case "map":
                    var template = $("#pinboardObject-map-template").html();
                    var html = Mustache.render(template, data);
                    $("#pinboard").append(html);
                    var obj = pb.find("p:contains(" + element.id + ")").closest(".pinboardObject");

                    obj.css({
                        "top": element.top,
                        "left": element.left,
                        "width": element.width,
                        "height": element.height
                    });

                    addMap(obj);
                    setMapToJSON(obj.attr("mapId"), element.center, element.marker, element.zoom, element.bearing, element.pitch);

                    localizeElement(obj,currentLang);
        
                    var handle = $("<div class='resize-handle'></div>").appendTo(obj);
                    TweenLite.set(handle, { top: element.height, left: element.width });

                    Draggable.create(obj, {
                        bounds: pinboard,
                        autoScroll: 2,
                        edgeResistance: 1,
                        type: "top,left"
                    });

                    Draggable.create(handle, {
                        type:"top,left",
                        bounds:{minX:200,minY:150,maxX:Number.MAX_VALUE,maxY:Number.MAX_VALUE},
                        onPress: function(e) {
                            e.stopPropagation(); // cancel drag
                        },
                        onDrag: function(e) {
                            TweenLite.set(this.target.parentNode, { width: this.x, height: this.y });
                        }
                    });
                    break;
                case "fl":
                    var template = $("#pinboardObject-fl-template").html();
                    var html = Mustache.render(template, data);
                    $("#pinboard").append(html);
                    var obj = pb.find("p:contains(" + element.id + ")").closest(".pinboardObject");

                    obj.css({
                        "top": element.top,
                        "left": element.left,
                        "width": element.width,
                        "height": element.height
                    });

                    setFileDetails(element.path, obj);
                    setFLImage(path.extname(element.path), obj);
                    localizeElement(obj,currentLang);
        
                    var handle = $("<div class='resize-handle'></div>").appendTo(obj);
                    TweenLite.set(handle, { top: element.height, left: element.width });

                    Draggable.create(obj, {
                        bounds: pinboard,
                        autoScroll: 2,
                        edgeResistance: 1,
                        type: "top,left"
                    });

                    Draggable.create(handle, {
                        type:"top,left",
                        bounds:{minX:200,minY:150,maxX:Number.MAX_VALUE,maxY:Number.MAX_VALUE},
                        onPress: function(e) {
                            e.stopPropagation(); // cancel drag
                        },
                        onDrag: function(e) {
                            TweenLite.set(this.target.parentNode, { width: this.x, height: this.y });
                        }
                    });
                    break;
                case "fol":
                    var template = $("#pinboardObject-fol-template").html();
                    var html = Mustache.render(template, data);
                    $("#pinboard").append(html);
                    var obj = pb.find("p:contains(" + element.id + ")").closest(".pinboardObject");

                    obj.css({
                        "top": element.top,
                        "left": element.left,
                        "width": element.width,
                        "height": element.height
                    });

                    setFileDetails(element.path, obj);
                    setFLImage("folder", obj);
                    localizeElement(obj,currentLang);
        
                    var handle = $("<div class='resize-handle'></div>").appendTo(obj);
                    TweenLite.set(handle, { top: element.height, left: element.width });

                    Draggable.create(obj, {
                        bounds: pinboard,
                        autoScroll: 2,
                        edgeResistance: 1,
                        type: "top,left"
                    });

                    Draggable.create(handle, {
                        type:"top,left",
                        bounds:{minX:200,minY:150,maxX:Number.MAX_VALUE,maxY:Number.MAX_VALUE},
                        onPress: function(e) {
                            e.stopPropagation(); // cancel drag
                        },
                        onDrag: function(e) {
                            TweenLite.set(this.target.parentNode, { width: this.x, height: this.y });
                        }
                    });
                    break;
            }

        }
    });


    setTimeout(switchLang(currentLang), 1);
    setTimeout(initTooltips, 1);

    // Gibt die zum Laden benötigte Zeit aus
    var elapsedTime = Date.now() - startTime;
    elapsedTime = (elapsedTime / 1000).toFixed(3);
    log("Loading Done after " + elapsedTime + "s", "s");
}